{"ast":null,"code":"/* global BigInt */\n// randomGenerators.js\n// Lógica de generadores congruenciales (Lineal y Multiplicativo) usando BigInt\n// Soporta dos modos para \"p\":\n//   - pEsCantidad=false (por defecto): p es el módulo m directamente (debe ser potencia de 2)\n//   - pEsCantidad=true          : p es la CANTIDAD de números a generar; el método deriva g y m con\n//                                 g = floor(log2(p)) + 2  y  m = 2^g, y usa n = p si no se pasa n.\n\n/** Convierte a BigInt de forma segura */\nconst B = v => {\n  if (typeof v === \"bigint\") return v;\n  if (typeof v === \"number\") return BigInt(Math.trunc(v));\n  if (typeof v === \"string\") return BigInt(v.trim());\n  throw new TypeError(\"Valor no convertible a BigInt: \" + v);\n};\n\n/** Máximo común divisor para BigInt */\n_c = B;\nconst gcdBI = (a, b) => {\n  a = B(a < 0n ? -a : a);\n  b = B(b < 0n ? -b : b);\n  while (b !== 0n) {\n    const t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n};\n\n/** ¿Es potencia de dos? (para BigInt) */\nconst isPow2BI = m => {\n  m = B(m);\n  return m > 0n && (m & m - 1n) === 0n;\n};\n\n/** log2 entero de una potencia de dos (para BigInt) */\nconst ilog2Pow2BI = m => {\n  m = B(m);\n  if (!isPow2BI(m)) throw new Error(\"m debe ser potencia de 2\");\n  let g = -1n;\n  while (m > 0n) {\n    m >>= 1n;\n    g++;\n  }\n  return Number(g);\n};\n\n/** Deriva m y g desde la cantidad p (números a generar): g=floor(log2(p))+2; m=2^g */\nconst deriveMFromCount = pCount => {\n  const pNum = Number(pCount);\n  if (!Number.isFinite(pNum) || pNum <= 0) throw new Error(\"p (cantidad) debe ser > 0\");\n  const g = Math.floor(Math.log2(pNum)) + 2;\n  const m = 1n << BigInt(g); // 2^g\n  return {\n    m,\n    g\n  };\n};\n\n/** Normaliza xi a [0,1) como Number. */\nconst normalize01 = (xi, m) => {\n  const denom = Number(m - 1n);\n  const num = Number(xi);\n  return denom > 0 ? num / denom : 0;\n};\n\n/** Valida entradas básicas */\nconst assertBasic = (params, necesitaC) => {\n  const {\n    x0,\n    k,\n    p,\n    d,\n    n,\n    pEsCantidad\n  } = params;\n  if ([x0, k, p, d].some(v => v === undefined || v === null)) throw new Error(\"Faltan parámetros requeridos: x0, k, p, d.\");\n  if (necesitaC && params.c === undefined) throw new Error(\"Falta parámetro: c.\");\n  if (!pEsCantidad) {\n    if (n === undefined || n === null) throw new Error(\"Falta n (cantidad).\");\n    if (B(n) <= 0n) throw new Error(\"n debe ser > 0.\");\n  }\n  if (B(p) <= 0n) throw new Error(\"p debe ser > 0.\");\n  if (B(d) < 0n) throw new Error(\"D (decimales) debe ser >= 0.\");\n};\n\n/**\n * Generador Congruencial Lineal (LCG con c>0):\n * Xi+1 = (a * Xi + c) mod m\n * Teoría:  m = 2^g  (potencia de 2),  a = 1 + 4k,  c coprimo con m,  g = log2(m)\n * Si pEsCantidad=true: p es la CANTIDAD; se deriva m y g como arriba.\n * Devuelve filas { i, xiPrev, operacion, xi, ri } y rows.meta = { a, m, g }\n */\nexport function lcgLineal({\n  x0,\n  k,\n  c,\n  p,\n  d,\n  n,\n  pEsCantidad = false\n}) {\n  assertBasic({\n    x0,\n    k,\n    p,\n    d,\n    n,\n    c,\n    pEsCantidad\n  }, true);\n  const a = 1n + 4n * B(k);\n  let m, g, N;\n  if (pEsCantidad) {\n    const {\n      m: mDer,\n      g: gDer\n    } = deriveMFromCount(Number(p));\n    m = mDer;\n    g = gDer;\n    N = Number(n !== null && n !== void 0 ? n : p);\n  } else {\n    m = B(p);\n    if (!isPow2BI(m)) throw new Error(\"Para el generador lineal, m (=P) debe ser potencia de 2 (m = 2^g).\");\n    g = ilog2Pow2BI(m);\n    N = Number(n);\n  }\n  if (gcdBI(B(c), m) !== 1n) throw new Error(\"Para el generador lineal, c debe ser relativamente primo con m.\");\n  let xi = B(x0);\n  const rows = [];\n  rows.meta = {\n    a: a.toString(),\n    m: m.toString(),\n    g\n  };\n  for (let i = 1; i <= N; i++) {\n    const xiPrev = xi;\n    const operacion = `(${a.toString()} * ${xiPrev.toString()} + ${B(c).toString()}) mod ${m.toString()}`;\n    xi = (a * xi + B(c)) % m;\n    const ri = normalize01(xi, m); // sin redondear aquí; la UI formatea con d decimales\n    rows.push({\n      i,\n      xiPrev: xiPrev.toString(),\n      operacion,\n      xi: xi.toString(),\n      ri\n    });\n  }\n  return rows;\n}\n\n/**\n * Generador Congruencial Multiplicativo (c=0):\n * Xi+1 = (a * Xi) mod m\n * Teoría:  m = 2^g (potencia de 2),  a = 3+8k **o** 5+8k,  X0 impar,  g = log2(m)\n * Si pEsCantidad=true: p es la CANTIDAD; se deriva m y g como arriba.\n * Devuelve filas { i, xiPrev, operacion, xi, ri } y rows.meta = { a, m, g }\n */\nexport function lcgMultiplicativo({\n  x0,\n  k,\n  p,\n  d,\n  n,\n  opcionA = \"3+8k\",\n  pEsCantidad = false\n}) {\n  assertBasic({\n    x0,\n    k,\n    p,\n    d,\n    n,\n    pEsCantidad\n  }, false);\n  let m, g, N;\n  if (pEsCantidad) {\n    const {\n      m: mDer,\n      g: gDer\n    } = deriveMFromCount(Number(p));\n    m = mDer;\n    g = gDer;\n    N = Number(n !== null && n !== void 0 ? n : p);\n  } else {\n    m = B(p);\n    if (!isPow2BI(m)) throw new Error(\"Para el generador multiplicativo, m (=P) debe ser potencia de 2 (m = 2^g).\");\n    g = ilog2Pow2BI(m);\n    N = Number(n);\n  }\n  if ((B(x0) & 1n) === 0n) throw new Error(\"Para el generador multiplicativo, x0 debe ser impar.\");\n  const base = opcionA === \"5+8k\" ? 5n : 3n;\n  const a = base + 8n * B(k);\n  let xi = B(x0);\n  const rows = [];\n  rows.meta = {\n    a: a.toString(),\n    m: m.toString(),\n    g\n  };\n  for (let i = 1; i <= N; i++) {\n    const xiPrev = xi;\n    const operacion = `(${a.toString()} * ${xiPrev.toString()}) mod ${m.toString()}`;\n    xi = a * xi % m;\n    const ri = normalize01(xi, m); // sin redondear aquí; la UI formatea con d decimales\n    rows.push({\n      i,\n      xiPrev: xiPrev.toString(),\n      operacion,\n      xi: xi.toString(),\n      ri\n    });\n  }\n  return rows;\n}\n\n/** Obtiene a, m y g para el algoritmo lineal a partir de m (no cantidad) */\nexport function linealParametros({\n  k,\n  m,\n  c\n}) {\n  const a = 1n + 4n * B(k);\n  const mBI = B(m);\n  if (!isPow2BI(mBI)) throw new Error(\"Para el generador lineal, m debe ser potencia de 2.\");\n  if (gcdBI(B(c), mBI) !== 1n) throw new Error(\"Para el generador lineal, c debe ser relativamente primo con m.\");\n  const g = ilog2Pow2BI(mBI);\n  return {\n    a: a.toString(),\n    m: mBI.toString(),\n    g\n  };\n}\n\n/** Devuelve solo el arreglo de ri (útil si no necesitas la tabla completa) */\nexport function soloRi(rows) {\n  return rows.map(r => r.ri);\n}\nvar _c;\n$RefreshReg$(_c, \"B\");","map":{"version":3,"names":["B","v","BigInt","Math","trunc","trim","TypeError","_c","gcdBI","a","b","t","isPow2BI","m","ilog2Pow2BI","Error","g","Number","deriveMFromCount","pCount","pNum","isFinite","floor","log2","normalize01","xi","denom","num","assertBasic","params","necesitaC","x0","k","p","d","n","pEsCantidad","some","undefined","c","lcgLineal","N","mDer","gDer","rows","meta","toString","i","xiPrev","operacion","ri","push","lcgMultiplicativo","opcionA","base","linealParametros","mBI","soloRi","map","r","$RefreshReg$"],"sources":["/Users/taniaperez/Documents/GitHub/diagramas_de_flujos/src/funciones/metCongruenciales.js"],"sourcesContent":["/* global BigInt */\n// randomGenerators.js\n// Lógica de generadores congruenciales (Lineal y Multiplicativo) usando BigInt\n// Soporta dos modos para \"p\":\n//   - pEsCantidad=false (por defecto): p es el módulo m directamente (debe ser potencia de 2)\n//   - pEsCantidad=true          : p es la CANTIDAD de números a generar; el método deriva g y m con\n//                                 g = floor(log2(p)) + 2  y  m = 2^g, y usa n = p si no se pasa n.\n\n/** Convierte a BigInt de forma segura */\nconst B = (v) => {\n  if (typeof v === \"bigint\") return v;\n  if (typeof v === \"number\") return BigInt(Math.trunc(v));\n  if (typeof v === \"string\") return BigInt(v.trim());\n  throw new TypeError(\"Valor no convertible a BigInt: \" + v);\n};\n\n/** Máximo común divisor para BigInt */\nconst gcdBI = (a, b) => {\n  a = B(a < 0n ? -a : a);\n  b = B(b < 0n ? -b : b);\n  while (b !== 0n) {\n    const t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n};\n\n/** ¿Es potencia de dos? (para BigInt) */\nconst isPow2BI = (m) => {\n  m = B(m);\n  return m > 0n && (m & (m - 1n)) === 0n;\n};\n\n/** log2 entero de una potencia de dos (para BigInt) */\nconst ilog2Pow2BI = (m) => {\n  m = B(m);\n  if (!isPow2BI(m)) throw new Error(\"m debe ser potencia de 2\");\n  let g = -1n;\n  while (m > 0n) {\n    m >>= 1n;\n    g++;\n  }\n  return Number(g);\n};\n\n/** Deriva m y g desde la cantidad p (números a generar): g=floor(log2(p))+2; m=2^g */\nconst deriveMFromCount = (pCount) => {\n  const pNum = Number(pCount);\n  if (!Number.isFinite(pNum) || pNum <= 0) throw new Error(\"p (cantidad) debe ser > 0\");\n  const g = Math.floor(Math.log2(pNum)) + 2;\n  const m = 1n << BigInt(g); // 2^g\n  return { m, g };\n};\n\n/** Normaliza xi a [0,1) como Number. */\nconst normalize01 = (xi, m) => {\n  const denom = Number(m - 1n);\n  const num = Number(xi);\n  return denom > 0 ? num / denom : 0;\n};\n\n/** Valida entradas básicas */\nconst assertBasic = (params, necesitaC) => {\n  const { x0, k, p, d, n, pEsCantidad } = params;\n  if ([x0, k, p, d].some((v) => v === undefined || v === null))\n    throw new Error(\"Faltan parámetros requeridos: x0, k, p, d.\");\n  if (necesitaC && params.c === undefined)\n    throw new Error(\"Falta parámetro: c.\");\n  if (!pEsCantidad) {\n    if (n === undefined || n === null) throw new Error(\"Falta n (cantidad).\");\n    if (B(n) <= 0n) throw new Error(\"n debe ser > 0.\");\n  }\n  if (B(p) <= 0n) throw new Error(\"p debe ser > 0.\");\n  if (B(d) < 0n) throw new Error(\"D (decimales) debe ser >= 0.\");\n};\n\n/**\n * Generador Congruencial Lineal (LCG con c>0):\n * Xi+1 = (a * Xi + c) mod m\n * Teoría:  m = 2^g  (potencia de 2),  a = 1 + 4k,  c coprimo con m,  g = log2(m)\n * Si pEsCantidad=true: p es la CANTIDAD; se deriva m y g como arriba.\n * Devuelve filas { i, xiPrev, operacion, xi, ri } y rows.meta = { a, m, g }\n */\nexport function lcgLineal({ x0, k, c, p, d, n, pEsCantidad = false }) {\n  assertBasic({ x0, k, p, d, n, c, pEsCantidad }, true);\n\n  const a = 1n + 4n * B(k);\n\n  let m, g, N;\n  if (pEsCantidad) {\n    const { m: mDer, g: gDer } = deriveMFromCount(Number(p));\n    m = mDer;\n    g = gDer;\n    N = Number(n ?? p);\n  } else {\n    m = B(p);\n    if (!isPow2BI(m)) throw new Error(\"Para el generador lineal, m (=P) debe ser potencia de 2 (m = 2^g).\");\n    g = ilog2Pow2BI(m);\n    N = Number(n);\n  }\n\n  if (gcdBI(B(c), m) !== 1n) throw new Error(\"Para el generador lineal, c debe ser relativamente primo con m.\");\n\n  let xi = B(x0);\n  const rows = [];\n  rows.meta = { a: a.toString(), m: m.toString(), g };\n\n  for (let i = 1; i <= N; i++) {\n    const xiPrev = xi;\n    const operacion = `(${a.toString()} * ${xiPrev.toString()} + ${B(c).toString()}) mod ${m.toString()}`;\n    xi = (a * xi + B(c)) % m;\n    const ri = normalize01(xi, m); // sin redondear aquí; la UI formatea con d decimales\n    rows.push({ i, xiPrev: xiPrev.toString(), operacion, xi: xi.toString(), ri });\n  }\n  return rows;\n}\n\n/**\n * Generador Congruencial Multiplicativo (c=0):\n * Xi+1 = (a * Xi) mod m\n * Teoría:  m = 2^g (potencia de 2),  a = 3+8k **o** 5+8k,  X0 impar,  g = log2(m)\n * Si pEsCantidad=true: p es la CANTIDAD; se deriva m y g como arriba.\n * Devuelve filas { i, xiPrev, operacion, xi, ri } y rows.meta = { a, m, g }\n */\nexport function lcgMultiplicativo({ x0, k, p, d, n, opcionA = \"3+8k\", pEsCantidad = false }) {\n  assertBasic({ x0, k, p, d, n, pEsCantidad }, false);\n\n  let m, g, N;\n  if (pEsCantidad) {\n    const { m: mDer, g: gDer } = deriveMFromCount(Number(p));\n    m = mDer;\n    g = gDer;\n    N = Number(n ?? p);\n  } else {\n    m = B(p);\n    if (!isPow2BI(m)) throw new Error(\"Para el generador multiplicativo, m (=P) debe ser potencia de 2 (m = 2^g).\");\n    g = ilog2Pow2BI(m);\n    N = Number(n);\n  }\n\n  if ((B(x0) & 1n) === 0n) throw new Error(\"Para el generador multiplicativo, x0 debe ser impar.\");\n\n  const base = opcionA === \"5+8k\" ? 5n : 3n;\n  const a = base + 8n * B(k);\n\n  let xi = B(x0);\n  const rows = [];\n  rows.meta = { a: a.toString(), m: m.toString(), g };\n\n  for (let i = 1; i <= N; i++) {\n    const xiPrev = xi;\n    const operacion = `(${a.toString()} * ${xiPrev.toString()}) mod ${m.toString()}`;\n    xi = (a * xi) % m;\n    const ri = normalize01(xi, m); // sin redondear aquí; la UI formatea con d decimales\n    rows.push({ i, xiPrev: xiPrev.toString(), operacion, xi: xi.toString(), ri });\n  }\n  return rows;\n}\n\n/** Obtiene a, m y g para el algoritmo lineal a partir de m (no cantidad) */\nexport function linealParametros({ k, m, c }) {\n  const a = 1n + 4n * B(k);\n  const mBI = B(m);\n  if (!isPow2BI(mBI)) throw new Error(\"Para el generador lineal, m debe ser potencia de 2.\");\n  if (gcdBI(B(c), mBI) !== 1n) throw new Error(\"Para el generador lineal, c debe ser relativamente primo con m.\");\n  const g = ilog2Pow2BI(mBI);\n  return { a: a.toString(), m: mBI.toString(), g };\n}\n\n/** Devuelve solo el arreglo de ri (útil si no necesitas la tabla completa) */\nexport function soloRi(rows) { return rows.map((r) => r.ri); }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}